<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Signal Links</title>
    <style>
      :root {
        color-scheme: dark;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: #0b0b0c;
        font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      }

      #root {
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
      import React, { useEffect, useRef } from "https://esm.sh/react@18.2.0";
      import { createRoot } from "https://esm.sh/react-dom@18.2.0/client";
      import * as d3 from "https://esm.sh/d3@7.9.0?bundle";

      const BURNT_ORANGE = "#CC5500";
      const BG_COLOR = "#0b0b0c";
      const LINK_COLOR = "rgba(255,255,255,0.18)";

      const DATA = {
        nodes: [
          { id: "hub", url: null, type: "hub" },
          { id: "Instagram", url: "https://instagram.com", type: "spoke" },
          { id: "Facebook", url: "https://facebook.com", type: "spoke" },
          { id: "Patreon", url: "https://patreon.com", type: "spoke" },
          { id: "TikTok", url: "https://tiktok.com", type: "spoke" },
          { id: "GitHub", url: "https://github.com", type: "spoke" }
        ],
        links: [
          { source: "hub", target: "Instagram" },
          { source: "hub", target: "Facebook" },
          { source: "hub", target: "Patreon" },
          { source: "hub", target: "TikTok" },
          { source: "hub", target: "GitHub" }
        ]
      };

      function LandingGraph() {
        const containerRef = useRef(null);
        const canvasRef = useRef(null);
        const simulationRef = useRef(null);
        const rafRef = useRef(null);

        useEffect(() => {
          const container = containerRef.current;
          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");
          canvas.style.cursor = "grab";

          const nodes = DATA.nodes.map((d) => ({ ...d }));
          const links = DATA.links.map((d) => ({ ...d }));

          let width = 0;
          let height = 0;
          let dpr = Math.max(1, window.devicePixelRatio || 1);

          function resize() {
            const { width: w, height: h } = container.getBoundingClientRect();
            width = Math.max(400, w);
            height = Math.max(400, h);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            if (simulationRef.current) {
              simulationRef.current
                .force("x", d3.forceX(() => width / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
                .force("y", d3.forceY(() => height / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
                .alpha(0.2)
                .restart();
            }
          }

          const simulation = d3
            .forceSimulation(nodes)
            .force(
              "link",
              d3
                .forceLink(links)
                .id((d) => d.id)
                .distance((l) => (l.source.id === "hub" ? 170 : 140))
                .strength(0.9)
            )
            .force("charge", d3.forceManyBody().strength(-700))
            .force("collision", d3.forceCollide().radius((d) => (d.id === "hub" ? 30 : 22)).strength(0.8))
            .force("x", d3.forceX(() => width / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
            .force("y", d3.forceY(() => height / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
            .velocityDecay(0.35)
            .alpha(0.9)
            .alphaTarget(0.02);

          simulationRef.current = simulation;

          let draggingNode = null;
          let dragMoved = false;
          let downPos = null;
          let downAt = 0;

          function getMouse(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
            };
          }

          function pickNode(x, y) {
            const rHit = 26;
            for (let i = nodes.length - 1; i >= 0; --i) {
              const n = nodes[i];
              const dx = x - (n.x || 0);
              const dy = y - (n.y || 0);
              if (dx * dx + dy * dy <= rHit * rHit) return n;
            }
            return null;
          }

          function pointerdown(evt) {
            const { x, y } = getMouse(evt);
            const n = pickNode(x, y);
            if (n) {
              draggingNode = n;
              dragMoved = false;
              downPos = { x, y };
              downAt = performance.now();
              n.fx = x;
              n.fy = y;
              simulation.alphaTarget(0.3).restart();
              canvas.style.cursor = "grabbing";
            }
          }

          function pointermove(evt) {
            if (!draggingNode) return;
            const { x, y } = getMouse(evt);
            draggingNode.fx = x;
            draggingNode.fy = y;
            if (!dragMoved && downPos) {
              const dx = x - downPos.x;
              const dy = y - downPos.y;
              dragMoved = Math.hypot(dx, dy) > 4;
            }
          }

          function pointerup() {
            const wasDragging = !!draggingNode;
            const released = draggingNode;
            if (draggingNode) {
              draggingNode.fx = null;
              draggingNode.fy = null;
              draggingNode = null;
              simulation.alphaTarget(0.06);
              setTimeout(() => simulation.alphaTarget(0.02), 120);
              canvas.style.cursor = "grab";
            }

            if (wasDragging && !dragMoved && released && released.url) {
              const elapsed = performance.now() - downAt;
              if (elapsed < 300) {
                window.open(released.url, "_blank", "noopener,noreferrer");
              }
            }

            downPos = null;
            downAt = 0;
            dragMoved = false;
          }

          canvas.addEventListener("pointerdown", pointerdown);
          window.addEventListener("pointermove", pointermove);
          window.addEventListener("pointerup", pointerup);

          const ro = new ResizeObserver(resize);
          ro.observe(container);
          resize();

          function draw() {
            const t = performance.now() * 0.001;
            const pulse = 1 + 0.06 * Math.sin(t * 0.9);

            ctx.save();
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, width, height);
            ctx.restore();

            ctx.save();
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = LINK_COLOR;
            ctx.globalAlpha = 0.9;
            links.forEach((l) => {
              if (!l.source || !l.target) return;
              ctx.beginPath();
              ctx.moveTo(l.source.x, l.source.y);
              ctx.lineTo(l.target.x, l.target.y);
              ctx.stroke();
            });
            ctx.restore();

            nodes.forEach((n, i) => {
              const isHub = n.id === "hub";
              const baseR = isHub ? 24 : 16;
              const r = baseR * (isHub ? pulse : 1 + 0.04 * Math.sin(t * 0.9 + i * 0.7));

              ctx.save();
              ctx.globalAlpha = 0.6;
              ctx.shadowColor = "rgba(204,85,0,0.9)";
              ctx.shadowBlur = 10;
              ctx.fillStyle = BURNT_ORANGE;
              ctx.beginPath();
              ctx.arc(n.x || 0, n.y || 0, r + 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();

              ctx.save();
              ctx.fillStyle = BURNT_ORANGE;
              ctx.strokeStyle = "#2d1200";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(n.x || 0, n.y || 0, r, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              ctx.restore();
            });

            ctx.save();
            ctx.font = "14px ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Inter, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#f5f5f5";
            nodes.forEach((n, i) => {
              if (n.id === "hub") return;
              const r = 16 * (1 + 0.04 * Math.sin(t * 0.9 + i * 0.7));
              const labelY = (n.y || 0) - (r + 12);
              ctx.fillText(n.id, n.x || 0, labelY);
            });
            ctx.restore();

            rafRef.current = requestAnimationFrame(draw);
          }

          simulation.on("tick", () => {});

          draw();

          return () => {
            cancelAnimationFrame(rafRef.current);
            simulation.stop();
            canvas.removeEventListener("pointerdown", pointerdown);
            window.removeEventListener("pointermove", pointermove);
            window.removeEventListener("pointerup", pointerup);
            ro.disconnect();
          };
        }, []);

        return React.createElement(
          "div",
          {
            ref: containerRef,
            style: {
              width: "100%",
              height: "100%",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              backgroundColor: BG_COLOR,
              overflow: "hidden"
            }
          },
          React.createElement("canvas", {
            ref: canvasRef,
            role: "img",
            "aria-label": "Hub-and-spoke social graph"
          })
        );
      }

      const rootElement = document.getElementById("root");
      createRoot(rootElement).render(React.createElement(LandingGraph));
    </script>
  </body>
</html>
