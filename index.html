<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title></title>
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        background: radial-gradient(circle at 18% 18%, #120d24 0%, #070616 45%, #01030b 100%);
        overflow: hidden;
      }

      svg {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      .link {
        stroke: rgba(255, 224, 122, 0.18);
        stroke-width: 1.6;
        stroke-linecap: round;
      }

      .node {
        fill: #ffe066;
        filter: url(#glow);
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  </head>
  <body>
    <svg id="stage" preserveAspectRatio="xMidYMid slice">
      <defs>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="4.6" result="blur" />
          <feMerge>
            <feMergeNode in="blur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
        <radialGradient id="vignette" cx="50%" cy="50%" r="75%">
          <stop offset="55%" stop-color="#0000" />
          <stop offset="100%" stop-color="#000b" />
        </radialGradient>
      </defs>
      <rect x="0" y="0" width="100%" height="100%" fill="#03030a" opacity="0.65" />
      <rect x="0" y="0" width="100%" height="100%" fill="url(#vignette)" opacity="0.85" />
    </svg>
    <script>
      (function () {
        const svg = d3.select('#stage');
        const gLinks = svg.append('g');
        const gNodes = svg.append('g');

        let width = svg.node().clientWidth;
        let height = svg.node().clientHeight;

        const nodes = [];
        const links = [];
        let idCounter = 0;

        const MIN_NODES = 48;
        const MAX_NODES = 210;
        const INITIAL_NODES = 140;

        const randomBetween = (min, max) => min + Math.random() * (max - min);
        const jitter = (range) => (Math.random() - 0.5) * range;
        const getId = (ref) => (typeof ref === 'object' ? ref.id : ref);

        function createNode(opts = {}) {
          const node = {
            id: `n${idCounter++}`,
            radius: opts.radius ?? randomBetween(10, 26),
            pulseOffset: Math.random() * Math.PI * 2,
          };
          node.x = opts.x ?? width / 2 + jitter(width * 0.35);
          node.y = opts.y ?? height / 2 + jitter(height * 0.35);
          node.vx = 0;
          node.vy = 0;
          nodes.push(node);
          return node;
        }

        function linkExists(aId, bId) {
          return links.some((link) => {
            const sourceId = getId(link.source);
            const targetId = getId(link.target);
            return (
              (sourceId === aId && targetId === bId) ||
              (sourceId === bId && targetId === aId)
            );
          });
        }

        function connectNodes(a, b) {
          const sourceId = getId(a);
          const targetId = getId(b);
          if (sourceId === targetId) return null;
          if (linkExists(sourceId, targetId)) return null;
          const link = {
            source: sourceId,
            target: targetId,
            shimmerOffset: Math.random() * Math.PI * 2,
          };
          links.push(link);
          return link;
        }

        for (let i = 0; i < INITIAL_NODES; i++) {
          createNode();
        }

        nodes.forEach((node, index) => {
          const peers = nodes.filter((_, i) => i !== index);
          const desired = Math.floor(randomBetween(3, 6));
          const shuffled = d3.shuffle(peers.slice());
          for (let i = 0; i < desired; i++) {
            connectNodes(node, shuffled[i]);
          }
        });

        let linkSel = gLinks.selectAll('line');
        let nodeSel = gNodes.selectAll('circle');

        const simulation = d3
          .forceSimulation(nodes)
          .force(
            'link',
            d3
              .forceLink(links)
              .id((d) => d.id)
              .distance(() => randomBetween(84, 140))
              .strength(0.12)
          )
          .force('charge', d3.forceManyBody().strength(-120))
          .force('collide', d3.forceCollide().radius((d) => d.radius + 8).iterations(3))
          .force('x', d3.forceX(() => width / 2).strength(0.014))
          .force('y', d3.forceY(() => height / 2).strength(0.014))
          .velocityDecay(0.58)
          .alphaDecay(0.04)
          .on('tick', ticked);

        function updateGraph() {
          linkSel = linkSel
            .data(links, (d) => `${getId(d.source)}--${getId(d.target)}`)
            .join(
              (enter) =>
                enter
                  .append('line')
                  .attr('class', 'link')
                  .attr('opacity', 0)
                  .call((enter) =>
                    enter
                      .transition()
                      .duration(600)
                      .attr('opacity', () => randomBetween(0.08, 0.22))
                  ),
              (update) => update,
              (exit) => exit.transition().duration(400).attr('opacity', 0).remove()
            );

          nodeSel = nodeSel
            .data(nodes, (d) => d.id)
            .join(
              (enter) =>
                enter
                  .append('circle')
                  .attr('class', 'node')
                  .attr('r', 0)
                  .attr('cx', width / 2)
                  .attr('cy', height / 2)
                  .call((enter) =>
                    enter
                      .transition()
                      .duration(720)
                      .attr('r', (d) => d.radius)
                  ),
              (update) => update,
              (exit) =>
                exit
                  .transition()
                  .duration(420)
                  .attr('r', 0)
                  .attr('opacity', 0)
                  .remove()
            );

          simulation.nodes(nodes);
          simulation.force('link').links(links);
          simulation.alpha(0.65).restart();
        }

        function ticked() {
          const time = performance.now() / 1000;

          nodeSel
            .attr('cx', (d) => d.x)
            .attr('cy', (d) => d.y)
            .attr('r', (d) => d.radius * (0.82 + 0.22 * Math.sin(time * 0.55 + d.pulseOffset)));

          linkSel
            .attr('x1', (d) => (typeof d.source === 'object' ? d.source.x : nodes.find((n) => n.id === d.source)?.x ?? 0))
            .attr('y1', (d) => (typeof d.source === 'object' ? d.source.y : nodes.find((n) => n.id === d.source)?.y ?? 0))
            .attr('x2', (d) => (typeof d.target === 'object' ? d.target.x : nodes.find((n) => n.id === d.target)?.x ?? 0))
            .attr('y2', (d) => (typeof d.target === 'object' ? d.target.y : nodes.find((n) => n.id === d.target)?.y ?? 0))
            .attr('stroke-width', (d) => 1.1 + 0.65 * Math.sin(time * 0.7 + d.shimmerOffset));
        }

        function addNodeWithLinks() {
          if (nodes.length >= MAX_NODES) return false;
          const node = createNode();
          const available = d3.shuffle(nodes.filter((n) => n !== node));
          const connections = Math.floor(randomBetween(3, 7));
          for (let i = 0; i < connections && i < available.length; i++) {
            connectNodes(node, available[i]);
          }
          return true;
        }

        function removeRandomNode() {
          if (nodes.length <= MIN_NODES) return false;
          const index = Math.floor(Math.random() * nodes.length);
          const [node] = nodes.splice(index, 1);
          const id = node.id;
          for (let i = links.length - 1; i >= 0; i--) {
            const sourceId = getId(links[i].source);
            const targetId = getId(links[i].target);
            if (sourceId === id || targetId === id) {
              links.splice(i, 1);
            }
          }
          return true;
        }

        function addRandomLink() {
          if (nodes.length < 2) return false;
          let attempts = 0;
          while (attempts < 20) {
            const a = nodes[Math.floor(Math.random() * nodes.length)];
            const b = nodes[Math.floor(Math.random() * nodes.length)];
            if (a !== b && !linkExists(a.id, b.id)) {
              connectNodes(a, b);
              return true;
            }
            attempts++;
          }
          return false;
        }

        function removeRandomLink() {
          if (links.length <= nodes.length * 0.6) return false;
          const index = Math.floor(Math.random() * links.length);
          links.splice(index, 1);
          return true;
        }

        function mutate() {
          const actions = [
            addNodeWithLinks,
            removeRandomNode,
            addRandomLink,
            removeRandomLink,
          ];
          const choice = actions[Math.floor(Math.random() * actions.length)];
          const changed = choice();
          if (changed) {
            updateGraph();
          }
        }

        updateGraph();

        const scheduleMutation = () => {
          mutate();
          const delay = randomBetween(1200, 2400);
          setTimeout(scheduleMutation, delay);
        };
        setTimeout(scheduleMutation, 1600);

        const resizeObserver = new ResizeObserver(() => {
          width = svg.node().clientWidth;
          height = svg.node().clientHeight;
          simulation.force('x', d3.forceX(() => width / 2).strength(0.024));
          simulation.force('y', d3.forceY(() => height / 2).strength(0.024));
          simulation.alpha(0.4).restart();
        });
        resizeObserver.observe(svg.node());
      })();
    </script>
  </body>
</html>
