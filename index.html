<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Signal Links</title>
    <style>
      :root {
        color-scheme: dark;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: #0b0b0c;
        font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      }

      #root {
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
      import React, { useEffect, useRef, useState } from "https://esm.sh/react@18.2.0";
      import { createRoot } from "https://esm.sh/react-dom@18.2.0/client";
      import * as d3 from "https://esm.sh/d3@7.9.0?bundle";
      import { load as loadYaml } from "https://esm.sh/js-yaml@4.1.0";

      const BURNT_ORANGE = "#CC5500";
      const BG_COLOR = "#0b0b0c";
      const LINK_COLOR = "rgba(255,255,255,0.18)";
      const CONFIG_URL = "graph-config.yaml";

      const FALLBACK_CONFIG = {
        hub: { label: "Signal Links", display: "Signal Links", href: null },
        spokes: [
          { display: "Instagram", href: "https://instagram.com" },
          { display: "Facebook", href: "https://facebook.com" },
          { display: "Patreon", href: "https://patreon.com" },
          { display: "TikTok", href: "https://tiktok.com" },
          { display: "GitHub", href: "https://github.com" }
        ]
      };

      const FALLBACK_GRAPH = buildGraphFromConfig(FALLBACK_CONFIG);

      async function fetchGraphConfig() {
        const response = await fetch(CONFIG_URL, { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Unable to load ${CONFIG_URL}: ${response.status}`);
        }

        const text = await response.text();
        if (!text.trim()) {
          throw new Error(`${CONFIG_URL} is empty`);
        }

        const parsed = loadYaml(text);
        return buildGraphFromConfig(parsed);
      }

      function buildGraphFromConfig(rawConfig) {
        const nodes = [];
        const links = [];

        const hubLabel = getString(rawConfig?.hub?.label) || getString(rawConfig?.hub?.display) || "Signal Links";
        const hubDisplay = getString(rawConfig?.hub?.display) || hubLabel;
        const hubHref = getString(rawConfig?.hub?.visit) || getString(rawConfig?.hub?.href) || null;

        nodes.push({
          id: "hub",
          type: "hub",
          display: hubDisplay,
          href: hubHref
        });

        const spokes = Array.isArray(rawConfig?.spokes) ? rawConfig.spokes : [];
        const usedIds = new Set(["hub"]);

        spokes.forEach((entry, index) => {
          const display =
            getString(entry?.display) ||
            getString(entry?.label) ||
            getString(entry?.text) ||
            getString(entry?.title) ||
            null;
          const href = getString(entry?.visit) || getString(entry?.href) || getString(entry?.url) || null;

          const fallbackDisplay = display || (href ? deriveDisplayFromUrl(href) : null) || `Link ${index + 1}`;
          let id = createNodeId(fallbackDisplay, index);
          while (usedIds.has(id)) {
            id = `${id}-${index + 1}`;
          }
          usedIds.add(id);

          nodes.push({
            id,
            type: "spoke",
            display: fallbackDisplay,
            href
          });

          links.push({ source: "hub", target: id });
        });

        return { nodes, links };
      }

      function getString(value) {
        if (typeof value !== "string") return null;
        const trimmed = value.trim();
        return trimmed.length ? trimmed : null;
      }

      function deriveDisplayFromUrl(url) {
        try {
          const parsed = new URL(url);
          return parsed.hostname.replace(/^www\./, "");
        } catch (err) {
          return url;
        }
      }

      function createNodeId(label, index) {
        if (!label) {
          return `spoke-${index + 1}`;
        }
        const slug = label
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-+|-+$/g, "");
        return slug ? `spoke-${slug}` : `spoke-${index + 1}`;
      }

      function LandingGraph() {
        const containerRef = useRef(null);
        const canvasRef = useRef(null);
        const simulationRef = useRef(null);
        const rafRef = useRef(null);
        const [graphData, setGraphData] = useState(FALLBACK_GRAPH);
        const [loadError, setLoadError] = useState(null);

        useEffect(() => {
          let cancelled = false;

          (async () => {
            try {
              const nextGraph = await fetchGraphConfig();
              if (!cancelled) {
                setGraphData(nextGraph);
                setLoadError(null);
              }
            } catch (error) {
              console.error(error);
              if (!cancelled) {
                setLoadError(error);
              }
            }
          })();

          return () => {
            cancelled = true;
          };
        }, []);

        useEffect(() => {
          if (!graphData) {
            return undefined;
          }

          const container = containerRef.current;
          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");
          canvas.style.cursor = "grab";

          const nodes = graphData.nodes.map((d) => ({ ...d }));
          const links = graphData.links.map((d) => ({ ...d }));

          let width = 0;
          let height = 0;
          let dpr = Math.max(1, window.devicePixelRatio || 1);
          let positioned = false;

          function applyInitialPositions() {
            const centerX = width / 2;
            const centerY = height / 2;
            const spokeNodes = nodes.filter((n) => n.type === "spoke");
            const radius = Math.max(140, Math.min(width, height) * 0.32);

            nodes.forEach((node) => {
              node.vx = 0;
              node.vy = 0;
            });

            const hubNode = nodes.find((n) => n.id === "hub") || nodes[0];
            if (hubNode) {
              hubNode.x = centerX;
              hubNode.y = centerY;
            }

            const count = Math.max(1, spokeNodes.length);
            spokeNodes.forEach((node, index) => {
              const angle = (index / count) * Math.PI * 2;
              node.x = centerX + radius * Math.cos(angle);
              node.y = centerY + radius * Math.sin(angle);
            });

            positioned = true;

            if (simulationRef.current) {
              simulationRef.current.alpha(0.9).restart();
            }
          }

          function resize() {
            const { width: w, height: h } = container.getBoundingClientRect();
            width = Math.max(400, w);
            height = Math.max(400, h);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            if (simulationRef.current) {
              simulationRef.current
                .force("x", d3.forceX(() => width / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
                .force("y", d3.forceY(() => height / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
                .alpha(0.2)
                .restart();
            }
            if (!positioned) {
              applyInitialPositions();
            }
          }

          const simulation = d3
            .forceSimulation(nodes)
            .force(
              "link",
              d3
                .forceLink(links)
                .id((d) => d.id)
                .distance((l) => {
                  const sourceId = typeof l.source === "string" ? l.source : l.source.id;
                  return sourceId === "hub" ? 170 : 140;
                })
                .strength(0.9)
            )
            .force("charge", d3.forceManyBody().strength(-700))
            .force("collision", d3.forceCollide().radius((d) => (d.id === "hub" ? 30 : 22)).strength(0.8))
            .force("x", d3.forceX(() => width / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
            .force("y", d3.forceY(() => height / 2).strength((d) => (d.id === "hub" ? 0.08 : 0.01)))
            .velocityDecay(0.35)
            .alpha(0.9)
            .alphaTarget(0.02);

          simulationRef.current = simulation;

          let draggingNode = null;
          let dragMoved = false;
          let downPos = null;
          let downAt = 0;

          function getMouse(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
            };
          }

          function pickNode(x, y) {
            const rHit = 26;
            for (let i = nodes.length - 1; i >= 0; --i) {
              const n = nodes[i];
              const dx = x - (n.x || 0);
              const dy = y - (n.y || 0);
              if (dx * dx + dy * dy <= rHit * rHit) return n;
            }
            return null;
          }

          function pointerdown(evt) {
            const { x, y } = getMouse(evt);
            const n = pickNode(x, y);
            if (n) {
              draggingNode = n;
              dragMoved = false;
              downPos = { x, y };
              downAt = performance.now();
              n.fx = x;
              n.fy = y;
              simulation.alphaTarget(0.3).restart();
              canvas.style.cursor = "grabbing";
            }
          }

          function pointermove(evt) {
            if (!draggingNode) return;
            const { x, y } = getMouse(evt);
            draggingNode.fx = x;
            draggingNode.fy = y;
            if (!dragMoved && downPos) {
              const dx = x - downPos.x;
              const dy = y - downPos.y;
              dragMoved = Math.hypot(dx, dy) > 4;
            }
          }

          function pointerup() {
            const wasDragging = !!draggingNode;
            const released = draggingNode;
            if (draggingNode) {
              draggingNode.fx = null;
              draggingNode.fy = null;
              draggingNode = null;
              simulation.alphaTarget(0.06);
              setTimeout(() => simulation.alphaTarget(0.02), 120);
              canvas.style.cursor = "grab";
            }

            if (wasDragging && !dragMoved && released && released.href) {
              const elapsed = performance.now() - downAt;
              if (elapsed < 300) {
                window.open(released.href, "_blank", "noopener,noreferrer");
              }
            }

            downPos = null;
            downAt = 0;
            dragMoved = false;
          }

          canvas.addEventListener("pointerdown", pointerdown);
          window.addEventListener("pointermove", pointermove);
          window.addEventListener("pointerup", pointerup);

          const ro = new ResizeObserver(() => {
            positioned = false;
            resize();
          });
          ro.observe(container);
          resize();

          function draw() {
            const t = performance.now() * 0.001;
            const pulse = 1 + 0.06 * Math.sin(t * 0.9);

            ctx.save();
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, width, height);
            ctx.restore();

            ctx.save();
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = LINK_COLOR;
            ctx.globalAlpha = 0.9;
            links.forEach((l) => {
              if (!l.source || !l.target) return;
              ctx.beginPath();
              ctx.moveTo(l.source.x, l.source.y);
              ctx.lineTo(l.target.x, l.target.y);
              ctx.stroke();
            });
            ctx.restore();

            nodes.forEach((n, i) => {
              const isHub = n.id === "hub";
              const baseR = isHub ? 24 : 16;
              const r = baseR * (isHub ? pulse : 1 + 0.04 * Math.sin(t * 0.9 + i * 0.7));

              ctx.save();
              ctx.globalAlpha = 0.6;
              ctx.shadowColor = "rgba(204,85,0,0.9)";
              ctx.shadowBlur = 10;
              ctx.fillStyle = BURNT_ORANGE;
              ctx.beginPath();
              ctx.arc(n.x || 0, n.y || 0, r + 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();

              ctx.save();
              ctx.fillStyle = BURNT_ORANGE;
              ctx.strokeStyle = "#2d1200";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(n.x || 0, n.y || 0, r, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              ctx.restore();
            });

            ctx.save();
            ctx.font = "14px ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Inter, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#f5f5f5";
            nodes.forEach((n, i) => {
              const display = n.display || n.id;
              if (n.id === "hub") {
                ctx.fillText(display, n.x || 0, (n.y || 0) - 36);
                return;
              }
              const r = 16 * (1 + 0.04 * Math.sin(t * 0.9 + i * 0.7));
              const labelY = (n.y || 0) - (r + 12);
              ctx.fillText(display, n.x || 0, labelY);
            });
            ctx.restore();

            rafRef.current = requestAnimationFrame(draw);
          }

          simulation.on("tick", () => {});

          draw();

          return () => {
            cancelAnimationFrame(rafRef.current);
            simulation.stop();
            canvas.removeEventListener("pointerdown", pointerdown);
            window.removeEventListener("pointermove", pointermove);
            window.removeEventListener("pointerup", pointerup);
            ro.disconnect();
          };
        }, [graphData]);

        return React.createElement(
          "div",
          {
            ref: containerRef,
            style: {
              width: "100%",
              height: "100%",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              backgroundColor: BG_COLOR,
              overflow: "hidden",
              position: "relative"
            }
          },
          React.createElement("canvas", {
            ref: canvasRef,
            role: "img",
            "aria-label": "Hub-and-spoke social graph"
          }),
          !graphData &&
            React.createElement(
              "div",
              {
                style: {
                  position: "absolute",
                  inset: 0,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  color: "#f5f5f5",
                  fontSize: "16px",
                  letterSpacing: "0.02em"
                }
              },
              "Loading graph..."
            ),
          loadError &&
            React.createElement(
              "div",
              {
                style: {
                  position: "absolute",
                  bottom: 16,
                  right: 16,
                  background: "rgba(0,0,0,0.6)",
                  padding: "8px 12px",
                  borderRadius: "8px",
                  fontSize: "12px",
                  color: "rgba(255,255,255,0.6)"
                }
              },
              "Using default links; update graph-config.yaml to customize."
            )
        );
      }

      const rootElement = document.getElementById("root");
      createRoot(rootElement).render(React.createElement(LandingGraph));
    </script>
  </body>
</html>
